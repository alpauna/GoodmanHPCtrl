# Bug #1: Defrost exit turns on CNT+FAN with Y inactive — compressor runs without indoor airflow

**Severity:** Critical (safety)
**Date discovered:** 2026-02-15
**Affected file:** `src/GoodmanHP.cpp`
**Fixed in:** `028e568` ("Fix defrost exit Y-inactive safety bug")

---

## Summary

When the thermostat satisfies (Y drops) during defrost Phase 1 or Phase 2 (before the compressor starts), a chain of bugs causes the defrost exit sequence to unconditionally turn on CNT (compressor contactor) and FAN approximately 60 seconds later — even though Y is no longer active. The heat pump runs without the indoor air handler, causing suction temperature to spike dangerously.

## Impact

- Compressor runs without indoor airflow (no heat exchange on indoor coil)
- Suction temperature climbs rapidly — peaked at **148.0°F** (8°F above the 140°F RV-fail threshold)
- Risk of compressor thermal lockout or damage
- Required manual reboot to stop

## Incident Timeline (2026-02-15)

| Time | Event | Suction Temp |
|------|-------|:------------:|
| 05:29:30 – 05:35:41 | Normal HEAT cycle, heat runtime accumulating | ~60°F |
| **05:35:41** | Heat runtime reaches 60 min threshold, defrost starts (Phase 1: all off) | — |
| 05:35:42 | State changed: HEAT -> DEFROST | — |
| 05:36:12 | Phase 1 complete (30s), Phase 2 starts: RV+W on, CNT waiting | — |
| **05:36:30** | **Y drops** (thermostat satisfied). Y-drop handler: RV off, W off, transition flags cleared. `_softwareDefrost` stays true (by design) | — |
| **05:36:30** | **BUG**: Same `update()` call — `checkDefrostNeeded()` sees `_softwareDefrost=true` + no transition flags. Computes `elapsed = millis() - _defrostStartTick`. `_defrostStartTick` is **0** (never set — Phase 3 never reached). `millis() - 0` >> 15 min. **False timeout fires.** | — |
| 05:36:30 | `stopSoftwareDefrost()` called — starts exit transition (`_defrostExiting=true`). Y-drop edge already processed, so this is never caught | — |
| 05:37:01 | Exit Phase 1 complete (30s): RV off, W off (already off) | ~60°F |
| **05:37:31** | **Exit Phase 2 complete: CNT ON, FAN ON** — no Y-active check! | 104°F |
| 05:37:34 | CNT 3s delay complete, compressor starts | — |
| 05:39:16 | Suction temp climbing rapidly (no indoor airflow) | 104°F |
| 05:40:16 | — | 120.5°F |
| 05:40:46 | — | 128.5°F |
| 05:41:46 | — | 137.5°F |
| **05:42:16** | **Suction crosses 140°F threshold** (not caught — state is OFF, not DEFROST) | **140.0°F** |
| 05:43:17 | — | **146.8°F** |
| 05:44:16 | — | **148.0°F** (peak) |
| **05:45:15** | Manual reboot via HTTPS | 146.9°F |
| 05:45:20 | System reboots, all outputs verified OFF | — |
| 05:48:19 | Startup lockout complete (180s) | — |
| 05:53:00 | Next normal HEAT cycle begins | — |

## Root Cause Analysis

Three interacting bugs in `checkDefrostNeeded()` and `stopSoftwareDefrost()`:

### Bug 1: `_defrostStartTick` is 0 when defrost never reaches Phase 3

`_defrostStartTick` is initialized to 0 in the constructor and only set at `GoodmanHP.cpp:973` when Phase 2 completes (Phase 3 begins):

```cpp
_defrostStartTick = now;  // Only set here — Phase 3 start
```

If Y drops during Phase 1 or Phase 2 (before Phase 3), `_defrostStartTick` remains **0**. When the Y-drop handler clears the transition flags (`_defrostTransition = false`, `_defrostCntPending = false`) but leaves `_softwareDefrost = true`, `checkDefrostNeeded()` falls through to the active defrost check:

```cpp
if (_softwareDefrost) {
    uint32_t elapsed = now - _defrostStartTick;  // now - 0 = huge number
    // ...
    if (elapsed >= DEFROST_TIMEOUT_MS) {          // Always true!
        stopSoftwareDefrost();                     // False timeout
    }
}
```

### Bug 2: `stopSoftwareDefrost()` starts exit transition without checking Y

`stopSoftwareDefrost()` unconditionally sets `_defrostExiting = true` and begins the 60-second exit sequence, even when called with Y inactive:

```cpp
void GoodmanHP::stopSoftwareDefrost() {
    // No Y-active check!
    _defrostExiting = true;
    _defrostTransition = true;
    _defrostTransitionStart = millis();
    // ...
}
```

### Bug 3: Exit Phase 2 completion turns on CNT+FAN without checking Y

The exit Phase 2 handler unconditionally turns on outputs:

```cpp
if (_defrostCntPending && _defrostExiting) {
    if (now - _defrostCntPendingStart >= _cntShortCycleMs) {
        // No Y-active check!
        cnt->turnOn();    // Compressor ON with Y inactive
        fan->turnOn();    // Outdoor fan ON with Y inactive
    }
}
```

### Bug 4: Ordering issue — `_defrostExiting` set after Y-drop edge already handled

The `_defrostExiting` cleanup in `checkYAndActivateCNT()` only runs inside the `!yActive && _yWasActive` block (the Y-drop edge). Since `_defrostExiting` is set by `stopSoftwareDefrost()` in `checkDefrostNeeded()` — which runs **after** `checkYAndActivateCNT()` in the same `update()` call — the Y-drop edge has already been consumed and can't catch it.

Execution order within `update()`:
1. `checkYAndActivateCNT()` — Y-drop edge fires, `_defrostExiting` is false, not caught
2. `updateState()` — State transitions DEFROST -> OFF
3. `checkDefrostNeeded()` — False timeout fires, sets `_defrostExiting = true` (too late)

### Why high suction temp check didn't trigger

The `checkHighSuctionTemp()` function only monitors suction temperature during active defrost. After the false timeout, `_softwareDefrost` was cleared and state was OFF. The 140°F threshold was crossed at 05:42:16 but not detected because the system was not in DEFROST state.

## Fix Applied

Defense-in-depth approach with 4 layers of protection in `src/GoodmanHP.cpp`:

### 1. Y-active safety gate at top of `checkDefrostNeeded()`

Added a master guard that cancels any active defrost/exit sequence when Y is not active:

```cpp
InputPin* yPin = getInput("Y");
bool yActive = (yPin != nullptr && yPin->isActive());
if (!yActive && (_defrostExiting || _defrostTransition || _defrostCntPending)) {
    // Turn all outputs OFF, clear all transition flags
    Log.warn("HP", "Y inactive during defrost/exit sequence, all outputs OFF");
    _defrostExiting = false;
    _defrostTransition = false;
    _defrostCntPending = false;
    return;
}
```

This catches the ordering issue (Bug 4) — even if `_defrostExiting` is set after the Y-drop edge, the next `update()` call will catch and cancel it.

### 2. `_defrostStartTick == 0` guard

Prevents false timeout when defrost never reached Phase 3:

```cpp
if (_softwareDefrost) {
    if (_defrostStartTick == 0) {
        return;  // Not yet in active phase, don't check timeout
    }
    // ... existing timeout/exit logic
}
```

### 3. Y-active check in `stopSoftwareDefrost()`

If Y is inactive when defrost ends, clean up flags without starting exit transition:

```cpp
InputPin* y = getInput("Y");
if (y == nullptr || !y->isActive()) {
    Log.info("HP", "Defrost stopped (Y inactive), no exit transition");
    _softwareDefrost = false;
    _defrostExiting = false;
    _defrostTransition = false;
    _defrostCntPending = false;
    // ... cleanup without starting exit
    return;
}
```

### 4. Reset `_defrostStartTick` on defrost stop

Prevents stale tick values from carrying over to future defrost cycles:

```cpp
_defrostStartTick = 0;
```

## Files Changed

- `src/GoodmanHP.cpp` — `checkDefrostNeeded()`, `stopSoftwareDefrost()`

## How to Reproduce

1. Set `heatRuntimeThresholdMs` to a low value (e.g., 60 min) so defrost triggers frequently
2. Let the heat pump accumulate runtime across multiple short HEAT cycles
3. When defrost starts (Phase 1 or Phase 2), have the thermostat satisfy (Y drops)
4. **Before fix:** CNT+FAN will turn on ~60s after Y drops, running the compressor without indoor airflow
5. **After fix:** All outputs stay OFF, `_softwareDefrost` flag preserved for resume on next Y activation

## Lessons Learned

- Uninitialized tick values (default 0) can cause `millis() - 0` overflow calculations to silently pass timeout checks
- Output activation functions should always verify the precondition (Y active) before turning on safety-critical outputs like the compressor
- When multiple handlers run in sequence within the same execution cycle, flags set by later handlers may not be caught by earlier handlers — a top-of-function safety gate is more robust than relying on edge detection
